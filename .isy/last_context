----- PROJECT INFO -----
Project Name: test
Description: voglio creare un cli che permette di utilizzare la completition di openia su tutta la codebase di un progetto. in questo modo lo sviluppatore potrà sviluppare utilizzando prompt linguistici che non sono strettamente correlati al linguaggio di programmazione, rendendo il coding molto piu accessibile. il concetto di base è che isy (il nome del progetto) crearà un context che comprenderà tutti i file specificati dall'utente e tramite structured output potrà modifica, creare, eliminare file con un interazione completa dell'os
----- END PROJECT INFO -----

----- START PROJECT TREE -----
./
├── .isy
│   ├── config.json
│   ├── last_context
│   └── token_usage.json
├── TODO
├── cmd
│   └── isy
│       ├── ask.go
│       ├── code.go
│       ├── context.go
│       ├── init.go
│       └── main.go
├── go.mod
├── go.sum
└── internal
    ├── config
    │   ├── init.go
    │   └── utils.go
    ├── context
    │   └── utils.go
    ├── openai
    │   ├── schemas
    │   │   └── ask
    │   │       └── ask.go
    │   └── utils.go
    └── operations
        └── code.go
----- END PROJECT TREE -----

----- START CONTEXT -----
----- START FILE -----
FILE: cmd/isy/ask.go
----- CONTENT -----
package main

import (
	"encoding/json"
	"fmt"
	"isy-cli/internal/context"
	localOpenAI "isy-cli/internal/openai"
	"isy-cli/internal/openai/schemas/ask"

	externalOpenAI "github.com/openai/openai-go"

	"github.com/spf13/cobra"
)

func AskCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "ask [query]",
		Short: "Ask OpenAI about your code",
		Long:  "Submit a natural language query about your codebase to OpenAI and get insights or explanations.",
		Args:  cobra.ExactArgs(1), // Richiede esattamente un argomento
		Run: func(cmd *cobra.Command, args []string) {
			// Legge la query dell'utente
			userQuery := args[0]

			// Genera il contesto utilizzando BuildContext
			contextContent, err := context.BuildContext()
			if err != nil {
				fmt.Println("Errore durante la generazione del contesto:", err)
				return
			}

			// Usa lo schema JSON e il prompt dal pacchetto schemas/ask
			systemPrompt := ask.SYSTEM_PROMPT

			schemaParams := externalOpenAI.ResponseFormatJSONSchemaJSONSchemaParam{
				Name:   externalOpenAI.F("ask_code_info"),
				Schema: externalOpenAI.F(ask.AskCodeInfoResponseSchema),
				Strict: externalOpenAI.Bool(true),
			}

			params := externalOpenAI.ChatCompletionNewParams{
				Model: externalOpenAI.F(externalOpenAI.ChatModelGPT4o),
				ResponseFormat: externalOpenAI.F[externalOpenAI.ChatCompletionNewParamsResponseFormatUnion](
					externalOpenAI.ResponseFormatJSONSchemaParam{
						Type:       externalOpenAI.F(externalOpenAI.ResponseFormatJSONSchemaTypeJSONSchema),
						JSONSchema: externalOpenAI.F(schemaParams),
					},
				),
				Messages: externalOpenAI.F([]externalOpenAI.ChatCompletionMessageParamUnion{
					externalOpenAI.SystemMessage(systemPrompt),
					externalOpenAI.UserMessage(userQuery),
					externalOpenAI.UserMessage(contextContent),
				}),
			}

			// Esegui la richiesta di completamento utilizzando OpenAI
			response, err := localOpenAI.RunCompletion(params)
			if err != nil {
				fmt.Println("Errore durante la richiesta a OpenAI:", err)
				return
			}

			askResponse := ask.AskCodeInfo{}
			_ = json.Unmarshal([]byte(response), &askResponse)

			// Stampa la risposta ricevuta
			fmt.Println("Risposta da OpenAI:")
			fmt.Println(askResponse)
		},
	}
}

----- END FILE -----

----- START FILE -----
FILE: cmd/isy/code.go
----- CONTENT -----
package main

import (
	"fmt"
	"isy-cli/internal/operations"

	"github.com/spf13/cobra"
)

func CodeCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "code",
		Short: "Modify your code with OpenAI assistance",
		Run: func(cmd *cobra.Command, args []string) {
			// Placeholder: Puoi espandere con parametri reali
			filePath := "example.go"   // Percorso file
			startLine := 10            // Riga iniziale
			endLine := 15              // Riga finale
			newCode := "new code here" // Nuovo codice

			fmt.Println("Editing code...")
			operations.ModifyFile(filePath, startLine, endLine, newCode)
		},
	}
}

----- END FILE -----

----- START FILE -----
FILE: cmd/isy/context.go
----- CONTENT -----
package main

import (
	"fmt"
	"isy-cli/internal/context"
	"isy-cli/internal/openai"
	"os"

	"github.com/spf13/cobra"
)

// ContextCommand definisce il comando CLI per generare il context
func ContextCommand() *cobra.Command {
	var verbose bool // Variabile per l'opzione verbose

	cmd := &cobra.Command{
		Use:   "context",
		Short: "Genera un context unificato dai file specificati nel progetto",
		Run: func(cmd *cobra.Command, args []string) {
			outputPath := ".isy/last_context" // File dove salvare il contesto

			// Genera il contesto utilizzando BuildContext
			contextContent, err := context.BuildContext()
			if err != nil {
				fmt.Println("Errore durante la generazione del contesto:", err)
				return
			}

			// Se l'opzione verbose è attiva, stampa il contesto in console
			if verbose {
				fmt.Println("\n--- Context Content ---")
				fmt.Println(contextContent)
			}

			// Scrive il contesto su un file
			err = os.WriteFile(outputPath, []byte(contextContent), 0644)
			if err != nil {
				fmt.Println("Errore durante la scrittura del file del contesto:", err)
				return
			}

			fmt.Println("Contesto generato e salvato in:", outputPath)

			token, err := openai.TokenizerCtx(contextContent)
			if err != nil {
				fmt.Println("Errore durante la tokenizzazione del contesto:", err)
				return
			}

			fmt.Println("Numero di token della codebase totale:", len(token))

		},
	}

	// Aggiungi l'opzione verbose
	cmd.Flags().BoolVarP(&verbose, "verbose", "v", false, "Stampa il contesto in console")

	return cmd
}

----- END FILE -----

----- START FILE -----
FILE: cmd/isy/init.go
----- CONTENT -----
package main

import (
	"isy-cli/internal/config"

	"github.com/spf13/cobra"
)

func InitCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "init",
		Short: "Initialize the project",
		Run: func(cmd *cobra.Command, args []string) {
			config.InitProject()
		},
	}
}

----- END FILE -----

----- START FILE -----
FILE: cmd/isy/main.go
----- CONTENT -----
package main

import (
	"fmt"

	"github.com/spf13/cobra"
)

func main() {
	var rootCmd = &cobra.Command{
		Use:   "isy",
		Short: "isy is your AI-powered coding assistant",
		Long:  "isy is a CLI tool to help you manage and edit your codebase with the power of OpenAI.",
	}

	// Aggiungi i comandi disponibili
	rootCmd.AddCommand(InitCommand())
	rootCmd.AddCommand(AskCommand())
	rootCmd.AddCommand(CodeCommand())
	rootCmd.AddCommand(ContextCommand()) // Aggiunto il comando context

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
	}
}

----- END FILE -----

----- START FILE -----
FILE: internal/config/init.go
----- CONTENT -----
package config

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func InitProject() {
	configPath := ".isy/config.json"

	// Verifica se la directory .isy esiste
	if _, err := os.Stat(".isy"); err == nil {
		fmt.Println("Il progetto è già stato inizializzato.")
		fmt.Print("Vuoi cancellare tutto e rifare l'init? (s/n): ")
		var response string
		fmt.Scanln(&response)
		if strings.ToLower(response) != "s" {
			fmt.Println("Operazione annullata.")
			return
		}

		// Cancella la directory
		err := os.RemoveAll(".isy")
		if err != nil {
			fmt.Println("Errore durante la cancellazione della directory:", err)
			return
		}
	}

	// Crea la directory .isy
	err := os.Mkdir(".isy", 0755)
	if err != nil {
		fmt.Println("Errore durante la creazione della directory:", err)
		return
	}

	reader := bufio.NewReader(os.Stdin)

	// Raccoglie i dati di configurazione dall'utente
	fmt.Println("Inserisci il nome del progetto:")
	projectName, _ := reader.ReadString('\n')
	projectName = strings.TrimSpace(projectName)

	fmt.Println("Inserisci il nome dell'autore o dell'azienda:")
	author, _ := reader.ReadString('\n')
	author = strings.TrimSpace(author)

	fmt.Println("Inserisci il linguaggio e/o framework da utilizzare:")
	languageAndFramework, _ := reader.ReadString('\n')
	languageAndFramework = strings.TrimSpace(languageAndFramework)

	fmt.Println("Descrivi il progetto (obiettivi, funzionalità, ecc.):")
	description, _ := reader.ReadString('\n')
	description = strings.TrimSpace(description)

	fmt.Println("Inserisci le estensioni dei file da includere (separate da spazi):")
	extensionsInput, _ := reader.ReadString('\n')
	extensions := strings.Fields(strings.TrimSpace(extensionsInput))

	fmt.Println("Inserisci la tua OpenAI API Key:")
	apiKey, _ := reader.ReadString('\n')
	apiKey = strings.TrimSpace(apiKey)

	// Aggiungi l'API key alla configurazione
	config := &Config{
		ProjectName:          projectName,
		Author:               author,
		LanguageAndFramework: languageAndFramework,
		Description:          description,
		Files:                extensions,
		APIKey:               apiKey, // Salva l'API key
	}

	// Salva la configurazione utilizzando SaveConfig
	err = SaveConfig(configPath, config)
	if err != nil {
		fmt.Println("Errore durante il salvataggio della configurazione:", err)
		return
	}

	fmt.Println("Progetto inizializzato con successo!")
	fmt.Printf("Nome progetto: %s\n", projectName)
	fmt.Printf("Autore: %s\n", author)
	fmt.Printf("Linguaggio/Framework: %s\n", languageAndFramework)
	fmt.Printf("Descrizione: %s\n", description)
	fmt.Println("Estensioni configurate:", strings.Join(extensions, ", "))
}

----- END FILE -----

----- START FILE -----
FILE: internal/config/utils.go
----- CONTENT -----
package config

import (
	"encoding/json"
	"fmt"
	"os"
)

// Config rappresenta la struttura del file di configurazione
type Config struct {
	ProjectName          string   `json:"project_name"`
	Author               string   `json:"author"`
	LanguageAndFramework string   `json:"language_and_framework"`
	Description          string   `json:"description"`
	Files                []string `json:"files"`
	APIKey               string   `json:"api_key"` // Nuovo campo
}

// LoadConfig legge il file di configurazione e restituisce un oggetto Config
func LoadConfig(configPath string) (*Config, error) {
	configFile, err := os.Open(configPath)
	if err != nil {
		return nil, fmt.Errorf("errore durante l'apertura del file di configurazione: %v", err)
	}
	defer configFile.Close()

	var config Config
	decoder := json.NewDecoder(configFile)
	err = decoder.Decode(&config)
	if err != nil {
		return nil, fmt.Errorf("errore durante la decodifica del file di configurazione: %v", err)
	}
	return &config, nil
}

// SaveConfig salva un oggetto Config nel file specificato
func SaveConfig(configPath string, config *Config) error {
	configFile, err := os.Create(configPath)
	if err != nil {
		return fmt.Errorf("errore durante la creazione del file di configurazione: %v", err)
	}
	defer configFile.Close()

	encoder := json.NewEncoder(configFile)
	encoder.SetIndent("", "  ") // Formatta il JSON con indentazione
	err = encoder.Encode(config)
	if err != nil {
		return fmt.Errorf("errore durante la scrittura del file di configurazione: %v", err)
	}
	return nil
}

// UpdateConfig aggiorna uno o più campi della configurazione e salva i cambiamenti
func UpdateConfig(configPath string, updates map[string]interface{}) error {
	config, err := LoadConfig(configPath)
	if err != nil {
		return err
	}

	// Applica gli aggiornamenti
	for key, value := range updates {
		switch key {
		case "project_name":
			if v, ok := value.(string); ok {
				config.ProjectName = v
			}
		case "author":
			if v, ok := value.(string); ok {
				config.Author = v
			}
		case "language_and_framework":
			if v, ok := value.(string); ok {
				config.LanguageAndFramework = v
			}
		case "description":
			if v, ok := value.(string); ok {
				config.Description = v
			}
		case "files":
			if v, ok := value.([]string); ok {
				config.Files = v
			}
		}
	}

	// Salva le modifiche
	return SaveConfig(configPath, config)
}

----- END FILE -----

----- START FILE -----
FILE: internal/context/utils.go
----- CONTENT -----
package context

import (
	"fmt"
	"io/ioutil"
	"isy-cli/internal/config"
	"os"
	"path/filepath"
	"strings"
)

func GenerateTree(baseDir string) (string, error) {
	var treeBuilder strings.Builder

	var buildTree func(string, string) error
	buildTree = func(currentDir, prefix string) error {
		entries, err := os.ReadDir(currentDir)
		if err != nil {
			return fmt.Errorf("errore durante la lettura della directory %s: %v", currentDir, err)
		}

		for i, entry := range entries {
			isLast := i == len(entries)-1
			connector := "├── "
			if isLast {
				connector = "└── "
			}

			treeBuilder.WriteString(fmt.Sprintf("%s%s%s\n", prefix, connector, entry.Name()))

			if entry.IsDir() {
				newPrefix := prefix
				if isLast {
					newPrefix += "    "
				} else {
					newPrefix += "│   "
				}
				err := buildTree(filepath.Join(currentDir, entry.Name()), newPrefix)
				if err != nil {
					return err
				}
			}
		}
		return nil
	}

	// Aggiungi la directory di base
	treeBuilder.WriteString(fmt.Sprintf("%s/\n", filepath.Base(baseDir)))
	err := buildTree(baseDir, "")
	if err != nil {
		return "", err
	}

	return treeBuilder.String(), nil
}

// MergeFiles legge e concatena i file specificati da un array di estensioni
func MergeFiles(baseDir string, extensions []string) (string, error) {
	var mergedContent strings.Builder

	// Itera attraverso i file nella directory di base
	err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Controlla che il file abbia una delle estensioni specificate
		if !info.IsDir() {
			for _, ext := range extensions {
				if strings.HasSuffix(info.Name(), ext) {
					// Legge il contenuto del file
					content, err := ioutil.ReadFile(path)
					if err != nil {
						return fmt.Errorf("errore durante la lettura del file %s: %v", path, err)
					}

					// Aggiunge il contenuto al risultato con i delimitatori
					mergedContent.WriteString("----- START FILE -----\n")
					mergedContent.WriteString(fmt.Sprintf("FILE: %s\n", path))
					mergedContent.WriteString("----- CONTENT -----\n")
					mergedContent.WriteString(string(content))
					mergedContent.WriteString("\n----- END FILE -----\n\n")
				}
			}
		}
		return nil
	})
	if err != nil {
		return "", fmt.Errorf("errore durante l'iterazione dei file: %v", err)
	}

	return mergedContent.String(), nil
}

func BuildContext() (string, error) {

	// Configurazione di base
	baseDir := "."                   // Directory di base
	configPath := ".isy/config.json" // Percorso del file di configurazione

	// Carica la configurazione del progetto
	cfg, err := config.LoadConfig(configPath)
	if err != nil {
		return "", fmt.Errorf("errore durante il caricamento della configurazione: %v", err)
	}

	// Genera l'albero dei file
	projectTree, err := GenerateTree(baseDir)
	if err != nil {
		return "", fmt.Errorf("errore durante la generazione dell'albero del progetto: %v", err)
	}

	// Unisce i contenuti dei file specificati
	mergedContent, err := MergeFiles(baseDir, cfg.Files)
	if err != nil {
		return "", fmt.Errorf("errore durante la generazione del contesto dei file: %v", err)
	}

	// Costruisce il contesto come stringa
	var contextBuilder strings.Builder

	// Aggiungi informazioni sul progetto
	contextBuilder.WriteString("----- PROJECT INFO -----\n")
	contextBuilder.WriteString(fmt.Sprintf("Project Name: %s\n", cfg.ProjectName))
	contextBuilder.WriteString(fmt.Sprintf("Description: %s\n", cfg.Description))
	contextBuilder.WriteString("----- END PROJECT INFO -----\n\n")

	// Aggiungi l'albero dei file
	contextBuilder.WriteString("----- START PROJECT TREE -----\n")
	contextBuilder.WriteString(projectTree)
	contextBuilder.WriteString("----- END PROJECT TREE -----\n\n")

	// Aggiungi i contenuti unificati dei file
	contextBuilder.WriteString("----- START CONTEXT -----\n")
	contextBuilder.WriteString(mergedContent)
	contextBuilder.WriteString("----- END CONTEXT -----\n\n")

	return contextBuilder.String(), nil
}

----- END FILE -----

----- START FILE -----
FILE: internal/openai/schemas/ask/ask.go
----- CONTENT -----
package ask

import (
	"isy-cli/internal/openai"
)

type AskCodeInfo struct {
	ContextualResponse string `json:"contextual_response" jsonschema_description:"A natural language response providing insights or suggestions based on the user query and the codebase" jsonschema:"type=string"`
}

var AskCodeInfoResponseSchema = openai.GenerateSchema[AskCodeInfo]()

// SYSTEM_PROMPT rappresenta il prompt di sistema specifico per "ask"
const SYSTEM_PROMPT = `You are an AI assistant integrated into a CLI tool designed to help developers interact with their codebase naturally.
Your goal is to analyze the user's query and provide relevant insights, explanations, or suggestions based on the project's context and files.

Follow these guidelines while responding:
1. Understand the user's query, which may include:
   - Explaining code snippets or logic.
   - Suggesting ways to implement new features.
   - Highlighting potential issues or areas for improvement.
   - Providing best practices or patterns for coding.
2. Use the context of the project, including its structure and code, to give accurate and coherent answers.
3. Avoid making assumptions beyond the given context. Focus on clarity and relevance.
4. Respond naturally and conversationally, adapting your tone and depth based on the complexity of the query.
5. Your responses should aim to help the user better understand or work with their codebase without directly modifying files.

Be a helpful, insightful, and approachable coding assistant!`

----- END FILE -----

----- START FILE -----
FILE: internal/openai/utils.go
----- CONTENT -----
package openai

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"isy-cli/internal/config"
	"os"
	"sync"

	"github.com/invopop/jsonschema"
	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
	"github.com/pkoukk/tiktoken-go"
)

var mu sync.Mutex // Per gestire l'accesso concorrente ai token globali

type TokenUsage struct {
	TokenInput  int64   `json:"token_input"`
	TokenOutput int64   `json:"token_output"`
	TotalCost   float64 `json:"total_cost"`
}

// Salva l'utilizzo dei token su disco
func saveTokenUsage(filePath string, usage TokenUsage) error {
	data, err := json.MarshalIndent(usage, "", "  ")
	if err != nil {
		return fmt.Errorf("errore durante la serializzazione dei dati token: %v", err)
	}
	return ioutil.WriteFile(filePath, data, 0644)
}

// Carica l'utilizzo dei token da disco
func loadTokenUsage(filePath string) (TokenUsage, error) {
	var usage TokenUsage
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		// Se il file non esiste, restituisce un utilizzo vuoto
		return usage, nil
	}
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return usage, fmt.Errorf("errore durante la lettura del file token: %v", err)
	}
	err = json.Unmarshal(data, &usage)
	if err != nil {
		return usage, fmt.Errorf("errore durante il parsing del file token: %v", err)
	}
	return usage, nil
}

func GenerateSchema[T any]() interface{} {
	// Structured Outputs uses a subset of JSON schema
	// These flags are necessary to comply with the subset
	reflector := jsonschema.Reflector{
		AllowAdditionalProperties: false,
		DoNotReference:            true,
	}
	var v T
	schema := reflector.Reflect(v)
	return schema
}

func TokenizerCtx(ctx string) ([]int, error) {
	encoding := "gpt-4o"

	tkm, err := tiktoken.EncodingForModel(encoding)
	if err != nil {
		fmt.Println("Errore durante la creazione del tokenizzatore:", err)
		return nil, err
	}

	token := tkm.Encode(ctx, nil, nil)

	return token, nil
}

func RunCompletion(params openai.ChatCompletionNewParams) (string, error) {
	// Percorso al file di configurazione e al file di utilizzo dei token
	configPath := ".isy/config.json"
	tokenUsagePath := ".isy/token_usage.json"

	// Carica la configurazione
	cfg, err := config.LoadConfig(configPath)
	if err != nil {
		return "", fmt.Errorf("errore durante il caricamento della configurazione: %v", err)
	}

	// Carica l'utilizzo corrente dei token
	currentUsage, err := loadTokenUsage(tokenUsagePath)
	if err != nil {
		return "", fmt.Errorf("errore durante il caricamento dell'utilizzo dei token: %v", err)
	}

	client := openai.NewClient(
		option.WithAPIKey(cfg.APIKey), // Imposta la chiave API
	)

	ctx := context.Background()

	// Esegui la richiesta di completamento
	chat, err := client.Chat.Completions.New(ctx, params, option.WithMaxRetries(5))
	if err != nil {
		return "", fmt.Errorf("errore durante la richiesta di completamento: %v", err)
	}

	// Aggiorna i token globali e calcola i costi
	mu.Lock()
	currentUsage.TokenInput += chat.Usage.PromptTokens
	currentUsage.TokenOutput += chat.Usage.CompletionTokens

	inputCost := float64(chat.Usage.PromptTokens) / 1_000_000 * 0.15
	outputCost := float64(chat.Usage.CompletionTokens) / 1_000_000 * 0.6
	currentUsage.TotalCost += inputCost + outputCost

	err = saveTokenUsage(tokenUsagePath, currentUsage)
	mu.Unlock()
	if err != nil {
		return "", fmt.Errorf("errore durante il salvataggio dell'utilizzo dei token: %v", err)
	}

	fmt.Printf("Token Input: %d - Token Output: %d\n", currentUsage.TokenInput, currentUsage.TokenOutput)
	fmt.Printf("Costo totale fino ad ora: $%.6f\n", currentUsage.TotalCost)

	// Ritorna direttamente la risposta grezza
	if len(chat.Choices) > 0 {
		return chat.Choices[0].Message.Content, nil
	}

	// Se non ci sono scelte nella risposta, ritorna stringa vuota e un errore
	return "", fmt.Errorf("nessuna risposta disponibile dalla completion")
}

----- END FILE -----

----- START FILE -----
FILE: internal/operations/code.go
----- CONTENT -----
package operations

import (
	"fmt"
	"io/ioutil"
	"strings"
)

func ModifyFile(filePath string, startLine, endLine int, newCode string) {
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	lines := strings.Split(string(content), "\n")

	// Controllo che startLine ed endLine siano validi
	if startLine < 1 || endLine > len(lines) || startLine > endLine {
		fmt.Println("Invalid line range")
		return
	}

	// Sostituzione del codice
	modifiedLines := append(lines[:startLine-1], append([]string{newCode}, lines[endLine:]...)...)
	modifiedContent := strings.Join(modifiedLines, "\n")

	// Scrittura del nuovo contenuto nel file
	err = ioutil.WriteFile(filePath, []byte(modifiedContent), 0644)
	if err != nil {
		fmt.Println("Error writing file:", err)
		return
	}

	fmt.Println("File modified successfully!")
}

----- END FILE -----

----- END CONTEXT -----

